#![warn(missing_docs)]
#![warn(clippy::todo)]

pub mod as_responses;
mod context;
mod convert;
pub mod handler;
pub mod handler_argument;
mod method;

use std::collections::BTreeMap;
use std::mem;
use std::sync::{Arc, Mutex};

use indexmap::IndexMap;
pub use swaggapi_macro::*;

pub use self::context::ApiContext;
pub use self::convert::convert_schema;
pub use self::handler::Handler;
pub use self::method::Method;

/// Reexports for macros and implementors
pub mod re_exports {
    #[cfg(feature = "actix")]
    pub use actix_web;
    #[cfg(feature = "axum")]
    pub use axum;
    pub use {indexmap, openapiv3, schemars};
}

use openapiv3::{Components, Info, OpenAPI, Operation, PathItem, Paths, ReferenceOr};
use schemars::gen::{SchemaGenerator, SchemaSettings};
use schemars::schema::Schema;

#[derive(SwaggapiPage)]
pub struct PageOfEverything;

pub trait SwaggapiPage {
    fn builder() -> &'static SwaggapiPageBuilder;
}

pub struct SwaggapiPageBuilder {
    title: &'static str,
    version: &'static str,
    state: Mutex<Option<SwaggapiPageBuilderState>>,
}

#[derive(Default)]
struct SwaggapiPageBuilderState {
    paths: Paths,

    /// The linkable schemas generated by [`SchemaGenerator`].
    ///
    /// (See [`SwaggapiPageBuilderState::generate_schema`] for more info)
    schemas: BTreeMap<String, Schema>,

    /// Cache for the result of [`SwaggapiPageBuilder::build`]
    last_build: Option<Arc<OpenAPI>>,
}

impl SwaggapiPageBuilder {
    pub const fn new() -> Self {
        Self {
            title: "",
            version: "",
            state: Mutex::new(None),
        }
    }

    pub fn add_handler(&self, handler: &Handler) {
        let mut guard = self.state.lock().unwrap();
        let state = guard.get_or_insert_with(Default::default);
        state.last_build = None;

        let (parameters, mut request_body, responses) = state.generate_schema(|gen| {
            let mut parameters = Vec::new();
            let mut request_body = Vec::new();
            for arg in handler.handler_arguments {
                if let Some(arg) = arg.as_ref() {
                    parameters.extend(
                        (arg.parameters)(&mut *gen)
                            .into_iter()
                            .map(ReferenceOr::Item),
                    );
                    request_body.extend((arg.request_body)(&mut *gen));
                }
            }
            let responses = (handler.responses)(&mut *gen);
            (parameters, request_body, responses)
        });

        let summary = handler.doc.get(0).map(|line| line.trim().to_string());
        let description = summary.clone().map(|summary| {
            handler
                .doc
                .get(1..)
                .unwrap_or(&[])
                .iter()
                .fold(summary, |text, line| format!("{text}\n{}", line.trim()))
        });

        let operation = Operation {
            summary,
            description,
            operation_id: Some(handler.ident.to_string()),
            parameters,
            request_body: request_body.pop().map(ReferenceOr::Item),
            responses,
            deprecated: handler.deprecated,
            security: None,   // TODO
            tags: Vec::new(), // TODO
            // Not supported:
            external_docs: Default::default(),
            servers: Default::default(),
            extensions: Default::default(),
            callbacks: Default::default(),
        };

        let ReferenceOr::Item(path) = state
            .paths
            .paths
            .entry(handler.path.to_string())
            .or_insert_with(|| ReferenceOr::Item(PathItem::default()))
        else {
            unreachable!("We only ever insert ReferenceOr::Item. See above")
        };
        let operation_mut = match handler.method {
            Method::Get => &mut path.get,
            Method::Post => &mut path.post,
            Method::Put => &mut path.put,
            Method::Delete => &mut path.delete,
            Method::Head => &mut path.head,
            Method::Options => &mut path.options,
            Method::Patch => &mut path.patch,
            Method::Trace => &mut path.trace,
        };
        *operation_mut = Some(operation);
    }

    pub fn build(&self) -> Arc<OpenAPI> {
        let mut guard = self.state.lock().unwrap();
        let state = guard.get_or_insert_with(Default::default);

        if let Some(open_api) = state.last_build.clone() {
            return open_api;
        }

        let open_api = Arc::new(OpenAPI {
            openapi: "3.0".to_string(),
            info: Info {
                title: self.title.to_string(),
                description: None,
                terms_of_service: None,
                contact: None,
                license: None,
                version: self.version.to_string(),
                extensions: IndexMap::new(),
            },
            servers: vec![],
            paths: state.paths.clone(),
            components: Some(Components {
                schemas: state
                    .schemas
                    .iter()
                    .map(|(key, schema)| (key.clone(), convert_schema(schema.clone())))
                    .collect(),
                ..Default::default()
            }),
            security: None,
            tags: vec![],
            external_docs: None,
            extensions: IndexMap::new(),
        });

        state.last_build = Some(open_api.clone());
        open_api
    }
}

impl SwaggapiPageBuilderState {
    /// Generate a schema, writing sub schemas to the state.
    ///
    /// [`SchemaGenerator`] is not [`Send`], so we can't just put it into our [`SwaggapiPageBuilderState`]
    /// which is "shared" across thread.
    /// So as awkward workaround, we only store [`SchemaGenerator`]'s relevant state, get a new generator for each schema
    /// and temporarily swap the relevant state with us.
    fn generate_schema<T>(&mut self, func: impl FnOnce(&mut SchemaGenerator) -> T) -> T {
        // Create SchemaGenerator and give him our schemas
        let mut settings = SchemaSettings::openapi3();
        settings.visitors = Vec::new();
        let mut gen = SchemaGenerator::new(settings);
        let definitions_mut = gen.definitions_mut();
        *definitions_mut = mem::take(&mut self.schemas);

        // Generate the new schema
        let schema = func(&mut gen);

        // Take our (potentially modified) schemas back
        self.schemas = gen.take_definitions();

        schema
    }
}
